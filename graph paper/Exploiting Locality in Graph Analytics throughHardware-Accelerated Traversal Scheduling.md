# Exploiting Locality in Graph Analytics throughHardware-Accelerated Traversal Scheduling

### 1.介绍

图算法的特点是高主存访问，原因：

1. 计算少，通信多
2. 图的不规则结构导致时间局部性差
3. 空间局部性差

真实世界的图结构更丰富，有强社区性，部分节点访问频率更高，具有潜在地局部性。

可以通过遍历顺序的调度来利用这种局部性。目前的软件图处理框架不能利用局部性，因为代价太大，所以软件框架以内存中节点的顺序来处理节点，即节点顺序调度。为了利用局部性，目前的框架可以通过预处理改变图分布，但代价昂贵。

本文利用硬件加速来实现局部性的遍历调度。提出HATS，一种在核附近的调度单元，提前运行并决定遍历哪一条边。具体提出限边DFS，即在限制深度内的DFS，使多个核同时遍历一个小的，连接性好的区域，改善空间局部性。

### 2.背景和动机

目前的图处理框架都是按照节点的编号顺序来处理的，并处理该点的边。这样对于边实现了空间局部性，但对邻居点没有局部性。

解耦访问-执行（DAE）：一个访问核执行所有访存操作，一个执行核执行所有计算操作，二者通过队列通信。HATS与此类似，在主核前面执行，但主核仍执行访存操作，HATS专注于图遍历

### 3.用BDFS改善局部性

每个BDFS遍历访问一块固定深度的连接点区域。

顺序点遍历（VO）对CSR的三个数组有好的空间局部性，但在访问邻居节点的数据时空间和时间局部性较差。

拆分访问标记数组来实现BDFS并行化，每个线程各自遍历自己的节点块。

### 4.HATS：硬件加速遍历调度

BDFS在软件上实现时得不偿失，因此提出硬件加速遍历调度（HATS）。

#### 系统架构

![image-20210916160503159](D:\notes\assets\Exploiting Locality in Graph Analytics throughHardware-Accelerated Traversal Scheduling\image-20210916160503159.png)

每个核配备一个HATS引擎，在核前面运行，并把边通过队列传给核，核来执行边操作。

#### A.HATS的接口和操作

##### 操作

1. 初始化

   > 初始化由软件进行，首先初始化所有需要的数据结构，例如图数据，以及可能需要的标记数组。这取决于图算法和遍历策略。VO-HATS只在每次迭代中不会激活所有节点的算法中需要标记数组；BDFS-HATS则总是需要标记数组。

2. HATS配置

   > 每个线程通过传递以下信息来配置自己的HATS：
   >
   > - CSR的三个数组和标记数组
   > - 遍历类型（拉或推）
   > - 这个HATS负责的图区域（开始和结束节点）
   
3. 处理

   > 在遍历过程中，HATS读取offset和neighbor数组，以及标记数组，并对BDFS更新标记数组，最终预取点数据。
   >
   > HATS找到未访问的点时，将边装进FIFO中。核用一个fetch_edge指令来从中取出边。如果HATS遍历完区域内的所有点，fetch_edge返回(-1,-1)。如果FIFO空了，fetch_edge将会终止核；如果满了，将会终止HATS。

##### 应用级透明

通过hats_configure()和hats_fetch_edges()两个API来分别执行配置和fetch_edge，对软件框架透明。

##### 并行和负载均衡

当某个HATS引擎提前完成工作后，将随机打断另一个线程，并分到一半的剩余工作。

##### 处理抢占

操作系统可能会由于线程调度而终止HATS，并保存其状态，包括剩下的节点区域，和所有数据结构的基地址。当该线程被重新调度时，就会用该状态配置HATS引擎。

##### API

- hats_configure()：配置HATS，传递offset，neighbor，vertex_data，bitvector4个数组，遍历类型（pull/push），这个HATS负责的区域（起止节点）
- hats_fetch_edges()：即fetch_edge指令

#### B.VO-HATS实现

![image-20210916161724337](D:\notes\assets\Exploiting Locality in Graph Analytics throughHardware-Accelerated Traversal Scheduling\image-20210916161724337.png)

1. scan维持HATS区域的当前和最后节点。
2. fetch offset获取输入的点id，并输出offset数组中的起止偏移。
3. fetch neighbor通过起止偏移输出该点的邻居id。
4. prefetch取出该点以及邻居的数据。

#### C.BDFS-HATS实现

![image-20210916161736797](D:\notes\assets\Exploiting Locality in Graph Analytics throughHardware-Accelerated Traversal Scheduling\image-20210916161736797.png)

BDFS的核心是一个定深栈，每层储存一个节点信息，深度等同于边界深度。等同于DFS，区别在于当栈被填满时，最顶层节点的邻居会被生成边送到FIFO，但不会遍历，也就是修改标记数组。当根节点的所有邻居都遍历完时，当前区域遍历完毕，scan会提供下一个根节点。

##### 并行优化

1. 将标记数组的检查和清零操作移出重要路径，并行执行。
2. 每层栈都会并行扩展两个邻居。这样，在该层当前节点的邻居完全探索完后，下一个节点已经准备就绪。

##### 将HATS扩展至拉遍历

推遍历中，检查标记数组是在探索邻居之前进行的；而拉遍历中先获取所有邻居，再进行标记数组检查。
