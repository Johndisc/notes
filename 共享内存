#### 整体步骤

```C++
int shmId = shmget((key_t)1234, 100, 0666|IPC_CREAT); //获取共享内存标志符
void *address = shmat(shmId, NULL, 0); //获取共享内存地址

//读写...

shmdt(address);	//断开进程与共享内存的连接
```

#### 创建内存

对于`shmget`所需的key_t值，有两种获取方法：

- `ftok`函数把一个已存在的路径名和一个整数标识符转换成一个key_t值
- 自己指定一个值

推荐第二种

#### 多次调用shmat

`shmat`是将共享内存的物理空间映射到进程的虚拟空间中。

一个进程是可以对同一个共享内存多次 `shmat`进行挂载的，物理内存是指向同一块，如果`shmaddr`为NULL，则每次返回的线性地址空间都不同，而且指向这块共享内存的引用计数会增加。 也就是进程多块线性空间会指向同一块物理地址。这样，如果之前挂载过这块共享内存的进程的线性地址没有被`shmdt`掉，即申请的线性地址都没有释放，就会一直消耗进程的虚拟内存空间。

#### 共享内存删除

**detach**

`int shmdt(const void *shmaddr);`

当一个进程完成某个共享内存区的使用时，它可调用`shmdt`断接这个内存区。

进程脱离共享内存区后，数据结构 `shmid_ds` 中的 `shm_nattch` 就会减 1 。但是 共享段内存依然存在，只有 `shm_attch` 为 0 后，即没有任何进程再使用该共享内存区，共享内存区才在内核中被删除。一般来说，当一个进程终止时，它所附加的共享内存区都会自动脱离。

**删除**

`int shmctl(int shmid , int cmd , struct shmid_ds *buff);`

cmd参数提供了三个命令：

- `IPC_RMID`   删除`shmid`标识的共享内存并拆除；
- `IPC_STAT`   （通过buff参数）向调用者返回所指定共享内存去当前的`shmid_ds`结构；
- `IPC_SET`   如果进程有相应的权限，将与共享内存相关联的值设置为`shmid_ds`数据结构中所提供的值。

也可以通过`shmctl`函数对共享内存进行诸如删除的操作。

如果共享内存已经与所有访问它的进程断开了连接，则调用`IPC_RMID`子命令后，系统将立即删除共享内存的标识符，并删除该共享内存区，以及所有相关的数据结构；如果仍有别的进程与该共享内存保持连接，则调用`IPC_RMID`子命令后，该共享内存并不会被立即从系统中删除，而是被设置为`IPC_PRIVATE`状态，并被标记为"已被删除"；直到已有连接全部断开，该共享内存才会最终从系统中消失。

一旦通过`shmctl`对共享内存进行了删除操作，则该共享内存将不能再接受任何新的连接，即使它依然存在于系统中！所以，可以确知， 在对共享内存删除之后不可能再有新的连接，则执行删除操作是安全的；否则，在删除操作之后如仍有新的连接发生，则这些连接都将可能失败！

**`shmdt`和`shmctl`的区别：**

1. `shmdt`  是将共享内存从进程空间detach出来，使进程中的`shmid`无效化，不可以使用，但是保留空间；
2. `shmctl(sid,IPC_RMID,0)`则是删除共享内存，彻底不可用，释放空间；

[API详细说明](https://codeantenna.com/index.php/a/yFthZ0jook)

