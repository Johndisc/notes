# GraphM: An Efficient Storage System for High Throughput ofConcurrent Graph Processing

## 1.介绍

大量的并发迭代图处理工作是在一个相同的云平台上执行的，但目前的工作主要集中在优化单个图处理任务。

为了实现高效的并发迭代图处理，有两个挑战需要解决：

1. 目前在同一个底层图上运行的并发任务没有考虑数据访问的相似性，造成了不必要的数据访问开销。

   > 并发迭代图处理任务常常重复遍历相同的图结构。然而由于图储存引擎和图处理框架的高度耦合，导致多份共享图数据的副本都被储存在cache或内存中，并且各自单独被访问，导致低效的数据访问和存储资源使用。

2. 各种图处理系统都和他们自己的储存引擎高度耦合。

   > 希望能将图处理系统与图储存系统解耦，共享一个优化的图处理系统。这样能将优化的储存系统关于处理引擎相整合来来实现迭代图处理应用的并发和高效执行，同时减小给用户的负担。

为了解决上述问题，提出储存系统GraphM。它是一个轻量的运行时系统，能在任何图处理系统上使用并支持迭代图处理任务的并发执行。提出共享同步机制来利用并发任务数据的相似性，能把多个特定任务共享的图结构数据解耦出来，只保存各个任务独特的数据，然后规定并发任务的遍历路径。

![image-20210914105217586](C:\Users\CGCL\AppData\Roaming\Typora\typora-user-images\image-20210914105217586.png)

## 2.GRAPHM概述

### 2.1系统架构

一般来说，一个迭代图处理任务所需要的数据包括图结构数据（例如G=(V,E,W)），任务特有的数据（例如PageRank的分数），标记为S。GraphM能将G标称共享的，包含3和主要的部分：图预处理器，图共享控制器，同步管理器。

#### 图预处理器

不同的图处理系统需要的图格式不同，因此处理之前先要用用户定义的convert()函数进格式转换。然后，将图划分为几个部分用于并行处理，并根据该任务的一般遍历顺序进一步被分块和编号，储存在LLC(last level cache)中，并用一个chunk_table数组记录每块的关键信息。

#### 图共享控制器

这个模块用来指定加载顺序并加载共享的图结构，仅被设计为一个简单的API，挂入现存的图处理系统。表示为
$$
Pij←Sharing(G,Load())
$$
G表示加载的图，Load()为图处理系统原本的加载操作，Pij表示第j个任务共享的一个加载的图结构部分Pi。

#### 同步管理器

不同的任务独自访问图，可能会跳过非活跃节点，计算复杂度也各不同。因此共享图数据会不规律地流入LLC，导致不必要的访存开销。因此，我们采用细粒度同步方式来利用任务之间的时间相似度。

具体步骤：每个任务需要在每轮迭代前说明每个块的计算负荷，然后据此分配计算资源，以此来同步图遍历。这样每个块只需要被载入到LLC一次，并在每次迭代中并发重复使用。

#### 编程API

为了调用GraphM，只需在图处理系统中添加我们的API。

- init()            通过预处理图来初始化GraphM
- sharing()    插入图处理系统中，替换掉原本的数据加载操作，对于不同的系统，函数参数不一样
- GetActiveVertices()        在每次迭代前获取活节点

### 2.2图预处理

CPU使用率和cache位置会被分块大小影响，表示为Sc。设置太大时会增加数据访问开销，因为当只有块的一部分能被加载进LLC时，剩下部分的加载会替换掉这部分，不同的并发任务会重复替换LLC，导致开销增大；设置太小会导致并发任务之间频繁的同步，因为只有当并发任务完成了对这个块的处理它们才能处理下一个。

Sc通过以下公式决定：
$$
S_{c}\times N+\frac{S_{c}\times N}{S_{G}}\times \left | V \right |\times U_{v}+r\leq C_{LLC}
$$
N表示CPU核数，CLLC表示LLC的大小，SG表示图数据的大小，|V|表示图的节点数，Uv表示每个节点的数据大小，r表示LLC的保留空间，Sc被设定为满足该不等式的最大值。

前者表示任务并行处理所需要的LLC大小（进程数=CPU核数），后者表示用来储存任务特定数据的LLC大小。通过这种设置，相同的块只会被加载到LLC中一次并被反复使用，只有任务特定的数据需要被其他任务替换。

在预处理阶段，会先遍历一遍，把每个部分按它们进入LLC的顺序进行标记。标记储存在表chunk_table中，入口是一个键值对，key是每块起始点的ID（表示为v），value是其块内出度。

### 2.3图结构共享内存